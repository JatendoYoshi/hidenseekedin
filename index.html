<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nearest Places Finder</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
body {
  margin: 0;
  font-family: Arial, sans-serif;
  background: #f4f6f8;
}
.container {
  max-width: 1000px;
  margin: auto;
  padding: 20px;
}
h1 { text-align: center; }

.controls {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 1fr;
  gap: 10px;
  margin-bottom: 10px;
}

input, select, button {
  padding: 12px;
  font-size: 16px;
}

button {
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
button.secondary { background: #6c757d; }

#map {
  height: 450px;
  border-radius: 8px;
  margin-bottom: 15px;
}

.result {
  background: white;
  padding: 15px;
  border-radius: 6px;
  box-shadow: 0 0 6px rgba(0,0,0,0.1);
  margin-bottom: 10px;
  line-height: 1.5;
}

.bus-box {
  background: #eef5ff;
  border-left: 5px solid #007bff;
}

.label-very { color: green; font-weight: bold; }
.label-close { color: orange; font-weight: bold; }
.label-far { color: red; font-weight: bold; }

@media (max-width: 768px) {
  .controls { grid-template-columns: 1fr; }
}
</style>
</head>

<body>
<div class="container">
<h1>Find the Nearest Places</h1>

<div class="controls">
  <input id="address" placeholder="Enter address or postcode">
  <select id="placeType">
    <option value="station">üöÜ Railway Station</option>
    <option value="retail">üõçÔ∏è Retail Park</option>
    <option value="cemetery">‚ö∞Ô∏è Cemetery</option>
    <option value="waitrose">üõí Waitrose</option>
  </select>
  <button onclick="searchByAddress()">Search</button>
  <button class="secondary" onclick="searchByLocation()">Use My Location</button>
</div>

<div id="map"></div>
<div id="busBox" class="result bus-box" style="display:none;"></div>
<div id="output" class="result">Start a search.</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ================= CONSTANTS ================= */
const SEARCH_RADIUS = 6000;
const WALK_SPEED_KMH = 2;

/* ================= MAP STATE ================= */
let map, originMarker;
let placeMarkers = [];

/* ================= FIXED DATA ================= */
const retailParks = [
  { name:"Hermiston Gait Retail Park", lat:55.92593, lon:-3.30701 },
  { name:"Meadowbank Retail Park", lat:55.95772, lon:-3.16502 },
  { name:"Craigleith Retail Park", lat:55.95794, lon:-3.24232 },
  { name:"Fort Kinnaird", lat:55.93485, lon:-3.10383 }
];

const waitroseStores = [
  { name:"Waitrose Comely Bank", lat:55.95916, lon:-3.22391 },
  { name:"Waitrose Morningside", lat:55.92980, lon:-3.20892 }
];

/* ================= MAP ================= */
function initMap(lat, lon) {
  map = L.map("map").setView([lat, lon], 14);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);
}

function clearMarkers() {
  placeMarkers.forEach(m => map.removeLayer(m));
  placeMarkers = [];
}

/* ================= SEARCH ================= */
async function searchByAddress() {
  const q = document.getElementById("address").value.trim();
  if (!q) return alert("Enter an address or postcode");

  const r = await fetch(
    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`
  );
  const d = await r.json();
  if (!d.length) return alert("Address not found");

  startSearch(+d[0].lat, +d[0].lon, "Search location");
}

function searchByLocation() {
  navigator.geolocation.getCurrentPosition(
    p => startSearch(p.coords.latitude, p.coords.longitude, "You are here"),
    () => alert("Location denied")
  );
}

async function startSearch(lat, lon, label) {
  if (!map) initMap(lat, lon);
  map.setView([lat, lon], 14);
  clearMarkers();

  if (originMarker) map.removeLayer(originMarker);
  originMarker = L.marker([lat, lon]).addTo(map).bindPopup(label).openPopup();

  await showClosestBusToUser(lat, lon);
  await findNearestPlaces(lat, lon);
}

/* ================= BUS STOP HELPERS ================= */
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2-lat1) * Math.PI/180;
  const dLon = (lon2-lon1) * Math.PI/180;
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1*Math.PI/180) *
    Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function getBusStopName(tags) {
  if (tags.name) return tags.name;
  if (tags.description) return tags.description;
  if (tags["addr:street"])
    return `Bus stop on ${tags["addr:street"]}`;
  return "Nearby bus stop";
}

/* ================= BUS STOP SEARCH ================= */
async function findClosestBusStop(lat, lon) {
  const query = `
    [out:json][timeout:10];
    (
      node["highway"="bus_stop"](around:${SEARCH_RADIUS},${lat},${lon});
      node["public_transport"="platform"](around:${SEARCH_RADIUS},${lat},${lon});
      way["public_transport"="platform"](around:${SEARCH_RADIUS},${lat},${lon});
      relation["public_transport"="stop_area"](around:${SEARCH_RADIUS},${lat},${lon});
    );
    out center tags;
  `;

  const r = await fetch("https://overpass.kumi.systems/api/interpreter", {
    method: "POST",
    body: query
  });
  const d = await r.json();

  const stops = (d.elements || [])
    .map(el => {
      const lat2 = el.lat ?? el.center?.lat;
      const lon2 = el.lon ?? el.center?.lon;
      if (!Number.isFinite(lat2) || !Number.isFinite(lon2)) return null;

      return {
        name: getBusStopName(el.tags || {}),
        routes: el.tags?.route_ref || "Routes not listed",
        dist: getDistance(lat, lon, lat2, lon2)
      };
    })
    .filter(Boolean)
    .sort((a,b)=>a.dist-b.dist);

  if (!stops.length) return "üöå No bus stop nearby";

  const s = stops[0];
  const mins = Math.round((s.dist / WALK_SPEED_KMH) * 60);

  let cls = "label-far";
  if (mins <= 5) cls = "label-very";
  else if (mins <= 12) cls = "label-close";

  return `
    <span class="${cls}">
      üöå ${s.name}<br>
      Routes: ${s.routes}<br>
      ${s.dist.toFixed(2)} km ¬∑ ${mins} min walk
    </span>
  `;
}

/* ================= USER BUS STOP ================= */
async function showClosestBusToUser(lat, lon) {
  const box = document.getElementById("busBox");
  box.style.display = "block";
  box.innerHTML = "<strong>Closest bus stop to you:</strong><br>Searching‚Ä¶";

  const bus = await findClosestBusStop(lat, lon);
  box.innerHTML = `<strong>Closest bus stop to you:</strong><br>${bus}`;
}

/* ================= PLACES ================= */
async function findNearestPlaces(originLat, originLon) {
  const type = document.getElementById("placeType").value;
  let places = [];

  if (type === "retail") places = retailParks;
  else if (type === "waitrose") places = waitroseStores;
  else {
    let filter = "";
    if (type === "station")
      filter = `node["railway"="station"](around:${SEARCH_RADIUS},${originLat},${originLon});`;
    if (type === "cemetery")
      filter = `
        way["landuse"="cemetery"](around:${SEARCH_RADIUS},${originLat},${originLon});
        relation["landuse"="cemetery"](around:${SEARCH_RADIUS},${originLat},${originLon});
      `;

    const q = `[out:json][timeout:10];(${filter});out center;`;
    const r = await fetch("https://overpass.kumi.systems/api/interpreter", {
      method: "POST",
      body: q
    });
    const d = await r.json();

    places = d.elements
      .map(e => ({
        name: e.tags?.name || "Unnamed",
        lat: Number(e.lat ?? e.center?.lat),
        lon: Number(e.lon ?? e.center?.lon)
      }))
      .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon));
  }

  places = places
    .map(p => ({ ...p, dist: getDistance(originLat, originLon, p.lat, p.lon) }))
    .sort((a,b)=>a.dist-b.dist)
    .slice(0,3);

  await Promise.all(
    places.map(async p => {
      p.bus = await findClosestBusStop(p.lat, p.lon);
    })
  );

  displayResults(places, originLat, originLon);
}

/* ================= DISPLAY ================= */
function displayResults(results, lat, lon) {
  let html = "<strong>Closest results:</strong><br><br>";
  const bounds = [[lat, lon]];

  results.forEach((p,i)=>{
    placeMarkers.push(L.marker([p.lat,p.lon]).addTo(map));
    bounds.push([p.lat,p.lon]);

    html += `
      ${["ü•á","ü•à","ü•â"][i]} ${p.name}<br>
      ${p.dist.toFixed(2)} km away<br>
      ${p.bus}<br><br>
    `;
  });

  map.fitBounds(bounds);
  document.getElementById("output").innerHTML = html;
}
</script>
</body>
</html>
