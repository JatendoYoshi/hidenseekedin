<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nearest Places Finder</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
body {
  margin: 0;
  font-family: Arial, sans-serif;
  background: #f4f6f8;
}

.container {
  max-width: 1000px;
  margin: auto;
  padding: 20px;
}

h1 {
  text-align: center;
}

.controls {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 1fr;
  gap: 10px;
  margin-bottom: 10px;
}

input, select, button {
  padding: 12px;
  font-size: 16px;
}

button {
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button.secondary {
  background: #6c757d;
}

#map {
  height: 450px;
  border-radius: 8px;
  margin-bottom: 15px;
}

.result {
  background: white;
  padding: 15px;
  border-radius: 6px;
  box-shadow: 0 0 6px rgba(0,0,0,0.1);
}

.distance {
  font-size: 14px;
}

.transport {
  font-size: 14px;
  margin-top: 4px;
}

.label-very { color: green; font-weight: bold; }
.label-close { color: orange; font-weight: bold; }
.label-far { color: red; font-weight: bold; }

@media (max-width: 768px) {
  .controls {
    grid-template-columns: 1fr;
  }
}
</style>
</head>

<body>
<div class="container">
<h1>Find the Nearest Places</h1>

<div class="controls">
  <input id="address" placeholder="Enter address or postcode">
  <select id="placeType">
    <option value="station">ğŸš† Railway Station</option>
    <option value="retail">ğŸ›ï¸ Retail Park</option>
    <option value="cemetery">âš°ï¸ Cemetery</option>
    <option value="waitrose">ğŸ›’ Waitrose</option>
  </select>
  <button onclick="searchByAddress()">Search</button>
  <button class="secondary" onclick="searchByLocation()">Use My Location</button>
</div>

<div id="map"></div>
<div id="output" class="result">Start a search.</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
let map, originMarker;
let resultMarkers = [];

/* FIXED DATASETS */
const retailParks = [
  { name: "Hermiston Gait Retail Park", lat: 55.92593, lon: -3.30701 },
  { name: "Meadowbank Retail Park", lat: 55.95772, lon: -3.16502 },
  { name: "Craigleith Retail Park", lat: 55.95794, lon: -3.24232 },
  { name: "Fort Kinnaird", lat: 55.93485, lon: -3.10383 }
];

const waitroseStores = [
  { name: "Waitrose Comely Bank", lat: 55.95916, lon: -3.22391 },
  { name: "Waitrose Morningside", lat: 55.92980, lon: -3.20892 }
];

function initMap(lat, lon) {
  map = L.map("map").setView([lat, lon], 14);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);
}

function clearMarkers() {
  resultMarkers.forEach(m => map.removeLayer(m));
  resultMarkers = [];
}

function setOrigin(lat, lon, label) {
  if (!map) initMap(lat, lon);
  map.setView([lat, lon], 14);

  if (originMarker) map.removeLayer(originMarker);
  clearMarkers();

  originMarker = L.marker([lat, lon]).addTo(map).bindPopup(label).openPopup();
  findNearestPlaces(lat, lon);
}

async function searchByAddress() {
  const addr = document.getElementById("address").value.trim();
  if (!addr) return alert("Enter an address");

  const res = await fetch(
    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(addr)}`
  );
  const data = await res.json();
  if (!data.length) return alert("Not found");

  setOrigin(Number(data[0].lat), Number(data[0].lon), "Search location");
}

function searchByLocation() {
  navigator.geolocation.getCurrentPosition(
    pos => setOrigin(pos.coords.latitude, pos.coords.longitude, "You are here"),
    () => alert("Location denied")
  );
}

async function findNearestPlaces(lat, lon) {
  const type = document.getElementById("placeType").value;
  let places = [];

  if (type === "retail") places = retailParks;
  else if (type === "waitrose") places = waitroseStores;
  else {
    let filter = "";
    if (type === "station")
      filter = `node["railway"="station"](around:6000,${lat},${lon});`;
    if (type === "cemetery")
      filter = `
        way["landuse"="cemetery"](around:6000,${lat},${lon});
        relation["landuse"="cemetery"](around:6000,${lat},${lon});
      `;

    const q = `[out:json];(${filter});out center;`;
    const r = await fetch("https://overpass.kumi.systems/api/interpreter", {
      method: "POST", body: q
    });
    const d = await r.json();

    places = d.elements.map(e => ({
      name: e.tags?.name || "Unnamed",
      lat: Number(e.lat || e.center.lat),
      lon: Number(e.lon || e.center.lon)
    }));
  }

  places = places
    .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon))
    .map(p => ({ ...p, distance: getDistance(lat, lon, p.lat, p.lon) }))
    .sort((a,b)=>a.distance-b.distance)
    .slice(0,3);

  for (const p of places) {
    p.transport = await findClosestBusStop(p.lat, p.lon);
  }

  displayResults(places, lat, lon);
}

/* âœ… COMPLETELY SAFE BUS STOP LOOKUP */
async function findClosestBusStop(lat, lon) {
  const query = `
    [out:json][timeout:8];
    node["highway"="bus_stop"](around:2000,${lat},${lon});
    out body;
  `;

  const res = await fetch("https://overpass.kumi.systems/api/interpreter", {
    method: "POST",
    body: query
  });

  const data = await res.json();
  if (!data.elements || !data.elements.length) {
    return "ğŸšŒ No bus stop nearby";
  }

  const validStops = data.elements
    .filter(s =>
      typeof s.lat === "number" &&
      typeof s.lon === "number"
    )
    .map(s => ({
      name: s.tags?.name || "Unnamed bus stop",
      lat: s.lat,
      lon: s.lon,
      routes: s.tags?.route_ref || s.tags?.routes || null,
      distance: getDistance(lat, lon, s.lat, s.lon)
    }))
    .filter(s => Number.isFinite(s.distance));

  if (!validStops.length) {
    return "ğŸšŒ No valid bus stop data";
  }

  const closest = validStops.sort((a,b)=>a.distance-b.distance)[0];
  const minutes = Math.round((closest.distance / 5) * 60);

  let label = "label-far";
  if (minutes <= 3) label = "label-very";
  else if (minutes <= 8) label = "label-close";

  const routesText = closest.routes
    ? `Routes: ${closest.routes}`
    : "Routes: Not available";

  return `
    <span class="${label}">
      ğŸšŒ ${closest.name}<br>
      ${routesText}<br>
      ${closest.distance.toFixed(2)} km Â· ${minutes} min walk
    </span>
  `;
}

function displayResults(results, lat, lon) {
  let html = "<strong>Closest results:</strong><br><br>";
  const bounds = [[lat, lon]];

  results.forEach((p,i) => {
    resultMarkers.push(L.marker([p.lat, p.lon]).addTo(map));
    bounds.push([p.lat, p.lon]);

    html += `
      ${["ğŸ¥‡","ğŸ¥ˆ","ğŸ¥‰"][i]} ${p.name}<br>
      <span class="distance">${p.distance.toFixed(2)} km away</span><br>
      <div class="transport">${p.transport}</div><br>
    `;
  });

  map.fitBounds(bounds);
  document.getElementById("output").innerHTML = html;
}

function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2-lat1) * Math.PI/180;
  const dLon = (lon2-lon1) * Math.PI/180;
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1*Math.PI/180) *
    Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
</script>
</body>
</html>
