<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nearest Places Finder</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
body {
  margin: 0;
  font-family: Arial, sans-serif;
  background: #f4f6f8;
}

.container {
  max-width: 1000px;
  margin: auto;
  padding: 20px;
}

h1 { text-align: center; }

.controls {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 1fr;
  gap: 10px;
  margin-bottom: 10px;
}

input, select, button {
  padding: 12px;
  font-size: 16px;
}

button {
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button.secondary { background: #6c757d; }

#map {
  height: 450px;
  border-radius: 8px;
  margin-bottom: 15px;
}

.result {
  background: white;
  padding: 15px;
  border-radius: 6px;
  box-shadow: 0 0 6px rgba(0,0,0,0.1);
}

.distance {
  font-size: 14px;
  color: #555;
}

.transport {
  font-size: 14px;
  margin-top: 4px;
  font-weight: bold;
}

.very-close { color: #28a745; }
.close { color: #fd7e14; }
.far { color: #dc3545; }

@media (max-width: 768px) {
  .controls { grid-template-columns: 1fr; }
}
</style>
</head>

<body>
<div class="container">
<h1>Find the Nearest Places</h1>

<div class="controls">
  <input id="address" placeholder="Enter address or postcode (optional)">
  <select id="placeType">
    <option value="station">üöÜ Railway Station</option>
    <option value="retail">üõçÔ∏è Retail Park</option>
    <option value="cemetery">‚ö∞Ô∏è Cemetery</option>
    <option value="waitrose">üõí Waitrose</option>
  </select>
  <button onclick="searchByAddress()">Search by Address</button>
  <button class="secondary" onclick="searchByLocation()">Use My Location</button>
</div>

<div id="map"></div>
<div id="output" class="result">Start a search to see results.</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
let map, originMarker;
let resultMarkers = [];
const cache = {};

/* FIXED DATASETS */
const retailParks = [
  { name: "Hermiston Gait Retail Park", lat: 55.92593, lon: -3.30701 },
  { name: "Meadowbank Retail Park", lat: 55.95772, lon: -3.16502 },
  { name: "Craigleith Retail Park", lat: 55.95794, lon: -3.24232 },
  { name: "Fort Kinnaird", lat: 55.93485, lon: -3.10383 }
];

const waitroseStores = [
  { name: "Waitrose Morningside", lat: 55.929797381971866, lon: -3.208918594119695 },
  { name: "Waitrose Comely Bank", lat: 55.95915605840695, lon: -3.22391060202278 }
];

/* ---------------- MAP ---------------- */

function initMap(lat, lon) {
  map = L.map("map").setView([lat, lon], 14);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);
}

function clearResults() {
  resultMarkers.forEach(m => map.removeLayer(m));
  resultMarkers = [];
}

function setOrigin(lat, lon, label) {
  if (!map) initMap(lat, lon);
  map.setView([lat, lon], 14);
  if (originMarker) map.removeLayer(originMarker);
  clearResults();
  originMarker = L.marker([lat, lon]).addTo(map).bindPopup(label).openPopup();
  findNearestPlaces(lat, lon);
}

/* ---------------- SEARCH ---------------- */

async function searchByAddress() {
  const address = document.getElementById("address").value.trim();
  if (!address) return alert("Please enter an address or postcode.");

  const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
  const data = await res.json();
  if (!data.length) return alert("Address not found.");

  setOrigin(+data[0].lat, +data[0].lon, "Search location");
}

function searchByLocation() {
  navigator.geolocation.getCurrentPosition(
    pos => setOrigin(pos.coords.latitude, pos.coords.longitude, "You are here"),
    () => alert("Location access denied")
  );
}

/* ---------------- MAIN LOGIC ---------------- */

async function findNearestPlaces(lat, lon) {
  const type = document.getElementById("placeType").value;
  const cacheKey = `${type}_${lat.toFixed(3)}_${lon.toFixed(3)}`;
  if (cache[cacheKey]) return displayResults(cache[cacheKey], lat, lon);

  let results = [];

  if (type === "retail") {
    results = retailParks
      .map(p => ({ ...p, distance: getDistance(lat, lon, p.lat, p.lon) }))
      .sort((a,b)=>a.distance-b.distance)
      .slice(0,3);
  }

  if (type === "waitrose") {
    results = waitroseStores
      .map(w => ({ ...w, distance: getDistance(lat, lon, w.lat, w.lon) }))
      .sort((a,b)=>a.distance-b.distance);
  }

  if (type === "station" || type === "cemetery") {
    let filter = "";
    if (type === "station")
      filter = `node["railway"="station"](around:6000,${lat},${lon});`;

    if (type === "cemetery")
      filter = `
        way["landuse"="cemetery"](around:6000,${lat},${lon});
        relation["landuse"="cemetery"](around:6000,${lat},${lon});
      `;

    const query = `[out:json][timeout:12];(${filter});out center;`;
    const res = await fetch("https://overpass-api.de/api/interpreter", {
      method: "POST",
      body: query
    });
    const data = await res.json();

    results = data.elements
      .filter(el => el.lat || el.center)
      .map(el => {
        const plat = el.lat || el.center.lat;
        const plon = el.lon || el.center.lon;
        return {
          name: el.tags?.name || "Unnamed location",
          lat: plat,
          lon: plon,
          distance: getDistance(lat, lon, plat, plon)
        };
      })
      .sort((a,b)=>a.distance-b.distance)
      .slice(0,3);
  }

  const busStops = await findBusStops(lat, lon);
  results.forEach(p => p.transport = nearestBusStop(p, busStops));

  cache[cacheKey] = results;
  displayResults(results, lat, lon);
}

/* ---------------- BUS STOPS ONLY ---------------- */

async function findBusStops(lat, lon) {
  const query = `
    [out:json][timeout:10];
    node["highway"="bus_stop"](around:2000,${lat},${lon});
    out body;
  `;

  const res = await fetch("https://overpass-api.de/api/interpreter", {
    method: "POST",
    body: query
  });
  const data = await res.json();
  return data.elements || [];
}

function nearestBusStop(place, busStops) {
  const valid = busStops
    .filter(b => b.lat && b.lon)
    .map(b => {
      const dist = getDistance(place.lat, place.lon, b.lat, b.lon);
      const walk = Math.round((dist / 5) * 60);

      let label = "Far", css = "far";
      if (walk <= 3) { label = "Very close"; css = "very-close"; }
      else if (walk <= 8) { label = "Close"; css = "close"; }

      return {
        text: `üöå Bus stop: ${b.tags.name || "Unnamed"} (${dist.toFixed(2)} km ¬∑ ${walk} min walk ¬∑ ${label})`,
        css,
        distance: dist
      };
    })
    .sort((a,b)=>a.distance-b.distance);

  if (!valid.length) return "No bus stop nearby";
  return `<span class="${valid[0].css}">${valid[0].text}</span>`;
}

/* ---------------- DISPLAY ---------------- */

function displayResults(results, lat, lon) {
  clearResults();
  let html = "<strong>Closest results:</strong><br><br>";
  const bounds = [[lat, lon]];

  results.forEach((p,i) => {
    resultMarkers.push(L.marker([p.lat, p.lon]).addTo(map).bindPopup(p.name));
    bounds.push([p.lat, p.lon]);

    html += `${["ü•á","ü•à","ü•â"][i]} ${p.name}<br>
      <span class="distance">${p.distance.toFixed(2)} km away</span><br>
      <div class="transport">${p.transport}</div><br>`;
  });

  map.fitBounds(bounds);
  document.getElementById("output").innerHTML = html;
}

/* ---------------- DISTANCE ---------------- */

function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2-lat1) * Math.PI/180;
  const dLon = (lon2-lon1) * Math.PI/180;
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(lat1*Math.PI/180) *
    Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}
</script>
</body>
</html>
