<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nearest Places Finder</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Leaflet (map rendering) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
/* ===========================
   BASIC PAGE STYLING
   =========================== */

body {
  margin: 0;
  font-family: Arial, Helvetica, sans-serif;
  background: #f4f6f8;
}

.container {
  max-width: 1000px;
  margin: auto;
  padding: 20px;
}

h1 {
  text-align: center;
}

/* ===========================
   CONTROLS
   =========================== */

.controls {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 1fr;
  gap: 10px;
  margin-bottom: 12px;
}

input,
select,
button {
  padding: 12px;
  font-size: 16px;
}

button {
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button.secondary {
  background: #6c757d;
}

/* ===========================
   MAP
   =========================== */

#map {
  height: 450px;
  border-radius: 8px;
  margin-bottom: 15px;
}

/* ===========================
   OUTPUT
   =========================== */

.result {
  background: white;
  padding: 15px;
  border-radius: 6px;
  box-shadow: 0 0 6px rgba(0,0,0,0.1);
  line-height: 1.5;
}

/* ===========================
   DISTANCE LABELS
   =========================== */

.label-very {
  color: green;
  font-weight: bold;
}

.label-close {
  color: orange;
  font-weight: bold;
}

.label-far {
  color: red;
  font-weight: bold;
}

/* ===========================
   MOBILE
   =========================== */

@media (max-width: 768px) {
  .controls {
    grid-template-columns: 1fr;
  }
}
</style>
</head>

<body>
<div class="container">

<h1>Find the Nearest Places</h1>

<div class="controls">
  <input id="address" placeholder="Enter address or postcode">
  <select id="placeType">
    <option value="station">üöÜ Railway Station</option>
    <option value="retail">üõçÔ∏è Retail Park</option>
    <option value="cemetery">‚ö∞Ô∏è Cemetery</option>
    <option value="waitrose">üõí Waitrose</option>
  </select>
  <button onclick="searchByAddress()">Search</button>
  <button class="secondary" onclick="searchByLocation()">Use My Location</button>
</div>

<div id="map"></div>
<div id="output" class="result">Start a search to see results.</div>

</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* =====================================================
   GLOBAL VARIABLES
   ===================================================== */

let map;
let originMarker;
let resultMarkers = [];

/* =====================================================
   FIXED DATASETS (RETAIL PARKS & WAITROSE)
   ===================================================== */

const retailParks = [
  { name: "Hermiston Gait Retail Park", lat: 55.92593, lon: -3.30701 },
  { name: "Meadowbank Retail Park", lat: 55.95772, lon: -3.16502 },
  { name: "Craigleith Retail Park", lat: 55.95794, lon: -3.24232 },
  { name: "Fort Kinnaird", lat: 55.93485, lon: -3.10383 }
];

const waitroseStores = [
  { name: "Waitrose Comely Bank", lat: 55.95916, lon: -3.22391 },
  { name: "Waitrose Morningside", lat: 55.92980, lon: -3.20892 }
];

/* =====================================================
   MAP INITIALISATION
   ===================================================== */

function initMap(lat, lon) {
  map = L.map("map").setView([lat, lon], 14);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(map);
}

/* =====================================================
   MARKER MANAGEMENT
   ===================================================== */

function clearMarkers() {
  resultMarkers.forEach(m => map.removeLayer(m));
  resultMarkers = [];
}

/* =====================================================
   ORIGIN SETTING
   ===================================================== */

function setOrigin(lat, lon, label) {
  if (!map) initMap(lat, lon);
  map.setView([lat, lon], 14);

  clearMarkers();

  if (originMarker) map.removeLayer(originMarker);
  originMarker = L.marker([lat, lon]).addTo(map).bindPopup(label).openPopup();

  findNearestPlaces(lat, lon);
}

/* =====================================================
   ADDRESS SEARCH
   ===================================================== */

async function searchByAddress() {
  const address = document.getElementById("address").value.trim();
  if (!address) {
    alert("Please enter an address or postcode.");
    return;
  }

  const response = await fetch(
    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`
  );
  const data = await response.json();

  if (!data.length) {
    alert("Address not found.");
    return;
  }

  setOrigin(+data[0].lat, +data[0].lon, "Search location");
}

/* =====================================================
   GEOLOCATION SEARCH
   ===================================================== */

function searchByLocation() {
  navigator.geolocation.getCurrentPosition(
    pos => setOrigin(pos.coords.latitude, pos.coords.longitude, "You are here"),
    () => alert("Location access denied.")
  );
}

/* =====================================================
   MAIN SEARCH LOGIC
   ===================================================== */

async function findNearestPlaces(lat, lon) {
  const type = document.getElementById("placeType").value;
  let places = [];

  /* ---------- FIXED DATA ---------- */
  if (type === "retail") places = retailParks;
  else if (type === "waitrose") places = waitroseStores;

  /* ---------- LIVE OSM DATA ---------- */
  else {
    let filter = "";

    if (type === "station")
      filter = `node["railway"="station"](around:6000,${lat},${lon});`;

    if (type === "cemetery")
      filter = `
        way["landuse"="cemetery"](around:6000,${lat},${lon});
        relation["landuse"="cemetery"](around:6000,${lat},${lon});
      `;

    const query = `[out:json][timeout:10];(${filter});out center;`;
    const res = await fetch("https://overpass.kumi.systems/api/interpreter", {
      method: "POST",
      body: query
    });
    const data = await res.json();

    places = data.elements.map(el => ({
      name: el.tags?.name || "Unnamed location",
      lat: +(el.lat || el.center.lat),
      lon: +(el.lon || el.center.lon)
    }));
  }

  /* ---------- DISTANCE SORT ---------- */
  places = places
    .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon))
    .map(p => ({
      ...p,
      distance: getDistance(lat, lon, p.lat, p.lon)
    }))
    .sort((a, b) => a.distance - b.distance)
    .slice(0, 3);

  /* ---------- BUS STOPS (PARALLEL) ---------- */
  await Promise.all(
    places.map(async place => {
      place.bus = await findClosestBusStop(place.lat, place.lon);
    })
  );

  displayResults(places, lat, lon);
}

/* =====================================================
   CLOSEST BUS STOP TO A PLACE
   ===================================================== */

async function findClosestBusStop(lat, lon) {
  const query = `
    [out:json][timeout:8];
    node["highway"="bus_stop"](around:6000,${lat},${lon});
    out tags;
  `;

  const res = await fetch("https://overpass.kumi.systems/api/interpreter", {
    method: "POST",
    body: query
  });
  const data = await res.json();

  if (!data.elements || !data.elements.length) {
    return "üöå No bus stop nearby";
  }

  const stops = data.elements
    .filter(s => Number.isFinite(s.lat) && Number.isFinite(s.lon))
    .map(s => ({
      name: s.tags?.name || "Unnamed bus stop",
      routes: s.tags?.route_ref || s.tags?.routes || null,
      distance: getDistance(lat, lon, s.lat, s.lon)
    }))
    .sort((a, b) => a.distance - b.distance);

  const stop = stops[0];
  const minutes = Math.round((stop.distance / 5) * 60);

  let labelClass = "label-far";
  if (minutes <= 3) labelClass = "label-very";
  else if (minutes <= 8) labelClass = "label-close";

  return `
    <span class="${labelClass}">
      üöå ${stop.name}<br>
      ${stop.routes ? `Routes: ${stop.routes}` : "Routes: Not available"}<br>
      ${stop.distance.toFixed(2)} km ¬∑ ${minutes} min walk
    </span>
  `;
}

/* =====================================================
   DISPLAY RESULTS
   ===================================================== */

function displayResults(results, lat, lon) {
  let html = "<strong>Closest results:</strong><br><br>";
  const bounds = [[lat, lon]];

  results.forEach((p, i) => {
    resultMarkers.push(L.marker([p.lat, p.lon]).addTo(map));
    bounds.push([p.lat, p.lon]);

    html += `
      ${["ü•á", "ü•à", "ü•â"][i]} ${p.name}<br>
      ${p.distance.toFixed(2)} km away<br>
      ${p.bus}<br><br>
    `;
  });

  map.fitBounds(bounds);
  document.getElementById("output").innerHTML = html;
}

/* =====================================================
   HAVERSINE DISTANCE FUNCTION
   ===================================================== */

function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1 * Math.PI / 180) *
    Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) ** 2;

  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
</script>
</body>
</html>
